<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `simple_parallel` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, simple_parallel">

    <title>simple_parallel - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'simple_parallel', ty: 'mod', relpath: '../'};</script>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>simple_parallel</a><wbr></span><span class='out-of-band'><a href='stability.html'>[stability]</a> <span id='render-detail'>
            <a id="collapse-all" href="#">[-]</a>&nbsp;<a id="expand-all" href="#">[+]</a>
        </span><a id='src-0' href='../src/simple_parallel/lib.rs.html#1-236'>[src]</a></span></h1>
<div class='docblock'><p>Straight-forward functions and types for basic data parallel
operations.</p>

<p>This library provides a few building blocks for operating on data
in parallel, particularly iterators. At the moment, it is not
designed to be robust or eek out every last drop of performance,
but rather explore some ways in which Rust&#39;s type system allows
for some fairly fancy things to be written with a guarantee of
safety, all without a garbage collector.</p>

<p>The only dependency is <code>std</code> and the basic functionality has no
<code>unsafe</code> code at all (the thread pool does use unsafe). Other than
the pool, parallelism is built directly from the functionality
provided by <code>std::thread</code> and <code>std::sync</code> and leverages their
correctness to automatically ensure the correctness of this
library (at the memory safety level).</p>

<p>The core design is to simply allow for operations that could occur
on a single thread to execute on many, it is not intending to
serve as a hard boundary between threads; in particular, if
something (a <code>panic!</code>) would take down the main thread when run
sequentially, it will also take down the main thread (eventually)
when run using the functions in this library.</p>

<p>On the point of performance and robustness, the top level
functions do no thread pooling and so everything essentially
spawns a new thread for each element, which is definitely
suboptimal for many reasons. Fortunately, not all is lost, the
functionality is designed to be as generic as possible, so the
iterator functions work with many many iterators, e.g. instead of
executing a thread on every element of a vector individually, a
user can divide that vector into disjoint sections and spread
those across much fewer threads (e.g. <a href="http://doc.rust-lang.org/nightly/std/slice/trait.SliceExt.html#tymethod.chunks">the <code>chunks</code>
method</a>).</p>

<p>Further, the thread pooling that does exist has a lot of
synchronisation overhead, and so is actually rarely a performance
improvement (although it is a robustness improvement over the
top-level functions, since it limits the number of threads that
will be spawned).</p>

<p>Either way, <strong>this is not recommended for general use</strong>.</p>

<h1 id="usage" class='section-header'><a
                           href="#usage">Usage</a></h1>
<p>This is <a href="https://crates.io/crates/simple_parallel">available on
crates.io</a>. Add this to
your Cargo.toml:</p>

<pre><code class="language-toml">[dependencies]
simple_parallel = &quot;0.1&quot;
</code></pre>

<p>The latest development version can be obtained <a href="https://github.com/huonw/simple_parallel">on
GitHub</a>.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1>
<p>Initialise an array, in parallel.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> [<span class='number'>0</span>; <span class='number'>10</span>];
<span class='comment'>// fill the array, with one thread for each element:</span>
<span class='ident'>simple_parallel</span>::<span class='ident'>for_</span>(<span class='ident'>data</span>.<span class='ident'>iter_mut</span>().<span class='ident'>enumerate</span>(), <span class='op'>|</span>(<span class='ident'>i</span>, <span class='ident'>elem</span>)<span class='op'>|</span> {
    <span class='op'>*</span><span class='ident'>elem</span> <span class='op'>=</span> <span class='ident'>i</span> <span class='kw'>as</span> <span class='ident'>i32</span>;
});

<span class='comment'>// now adjust that data, with a threadpool:</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pool</span> <span class='op'>=</span> <span class='ident'>simple_parallel</span>::<span class='ident'>Pool</span>::<span class='ident'>new</span>(<span class='number'>4</span>);
<span class='ident'>pool</span>.<span class='ident'>for_</span>(<span class='ident'>data</span>.<span class='ident'>iter_mut</span>(), <span class='op'>|</span><span class='ident'>elem</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>elem</span> <span class='op'>*=</span> <span class='number'>2</span>);
</pre>

<p>Transform each element of an ordered map in a fancy way, in
parallel, with <code>map</code> (<code>map</code> ensures the output order matches the
input order, unlike <code>unordered_map</code>),</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>map</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='string'>&#39;a&#39;</span>, <span class='number'>1</span>);
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='string'>&#39;x&#39;</span>, <span class='number'>55</span>);

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='op'>|</span>(<span class='kw-2'>&amp;</span><span class='ident'>c</span>, <span class='kw-2'>&amp;</span><span class='ident'>elem</span>): (<span class='kw-2'>&amp;</span><span class='ident'>char</span>, _)<span class='op'>|</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>elem</span>  <span class='op'>*</span> <span class='ident'>c</span> <span class='kw'>as</span> <span class='ident'>i32</span>;
    <span class='comment'>// ... something complicated and expensive ...</span>
    <span class='kw'>return</span> <span class='ident'>x</span> <span class='kw'>as</span> <span class='ident'>f64</span>
};

<span class='comment'>// (`IntoIterator` is used, so &quot;direct&quot; iteration like this is fine.)</span>
<span class='kw'>let</span> <span class='ident'>par_iter</span> <span class='op'>=</span> <span class='ident'>simple_parallel</span>::<span class='ident'>map</span>(<span class='kw-2'>&amp;</span><span class='ident'>map</span>, <span class='kw-2'>&amp;</span><span class='ident'>f</span>);

<span class='comment'>// the computation is executing on several threads in the</span>
<span class='comment'>// background, so that elements are hopefully ready as soon as</span>
<span class='comment'>// possible.</span>

<span class='kw'>for</span> <span class='ident'>value</span> <span class='kw'>in</span> <span class='ident'>par_iter</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;I computed {}&quot;</span>, <span class='ident'>value</span>);
}
</pre>

<p>Sum an arbitrarily long slice, in parallel, by summing subsections and adding
everything to a shared mutex, stored on the stack of the main
thread. (A parallel fold is currently missing, hence the mutex.)</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>Mutex</span>;

<span class='comment'>// limit the spew of thread spawning to something sensible</span>
<span class='kw'>const</span> <span class='ident'>NUM_CHUNKS</span>: <span class='ident'>usize</span> <span class='op'>=</span> <span class='number'>8</span>;

<span class='kw'>fn</span> <span class='ident'>sum</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='comment'>// (round up)</span>
    <span class='kw'>let</span> <span class='ident'>elements_per_chunk</span> <span class='op'>=</span> (<span class='ident'>x</span>.<span class='ident'>len</span>() <span class='op'>+</span> <span class='ident'>NUM_CHUNKS</span> <span class='op'>-</span> <span class='number'>1</span>) <span class='op'>/</span> <span class='ident'>NUM_CHUNKS</span>;

    <span class='kw'>let</span> <span class='ident'>total</span> <span class='op'>=</span> <span class='ident'>Mutex</span>::<span class='ident'>new</span>(<span class='number'>0.0</span>);
    <span class='ident'>simple_parallel</span>::<span class='ident'>for_</span>(<span class='ident'>x</span>.<span class='ident'>chunks</span>(<span class='ident'>elements_per_chunk</span>), <span class='op'>|</span><span class='ident'>chunk</span><span class='op'>|</span> {
        <span class='comment'>// sum up this little subsection</span>
        <span class='kw'>let</span> <span class='ident'>subsum</span> <span class='op'>=</span> <span class='ident'>chunk</span>.<span class='ident'>iter</span>().<span class='ident'>fold</span>(<span class='number'>0.0</span>, <span class='op'>|</span><span class='ident'>a</span>, <span class='ident'>b</span><span class='op'>|</span> <span class='ident'>a</span> <span class='op'>+</span> <span class='op'>*</span><span class='ident'>b</span>);
        <span class='op'>*</span><span class='ident'>total</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>() <span class='op'>+=</span> <span class='ident'>subsum</span>;
    });

    <span class='kw'>let</span> <span class='ident'>answer</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>total</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
    <span class='ident'>answer</span>
}
</pre>

<p>Alternatively, one could use a thread pool, and assign an absolute
number of elements to each subsection and let the pool manage
distributing the work among threads, instead of being forced to
computing the length of the subsections to limit the number of
threads spawned.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>Mutex</span>;

<span class='comment'>// limit the spew of thread spawning to something sensible</span>
<span class='kw'>const</span> <span class='ident'>ELEMS_PER_JOB</span>: <span class='ident'>usize</span> <span class='op'>=</span> <span class='number'>1_000</span>;

<span class='kw'>fn</span> <span class='ident'>pooled_sum</span>(<span class='ident'>pool</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>simple_parallel</span>::<span class='ident'>Pool</span>, <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>let</span> <span class='ident'>total</span> <span class='op'>=</span> <span class='ident'>Mutex</span>::<span class='ident'>new</span>(<span class='number'>0.0</span>);
    <span class='ident'>simple_parallel</span>::<span class='ident'>for_</span>(<span class='ident'>x</span>.<span class='ident'>chunks</span>(<span class='ident'>ELEMS_PER_JOB</span>), <span class='op'>|</span><span class='ident'>chunk</span><span class='op'>|</span> {
        <span class='comment'>// sum up this little subsection</span>
        <span class='kw'>let</span> <span class='ident'>subsum</span> <span class='op'>=</span> <span class='ident'>chunk</span>.<span class='ident'>iter</span>().<span class='ident'>fold</span>(<span class='number'>0.0</span>, <span class='op'>|</span><span class='ident'>a</span>, <span class='ident'>b</span><span class='op'>|</span> <span class='ident'>a</span> <span class='op'>+</span> <span class='op'>*</span><span class='ident'>b</span>);
        <span class='op'>*</span><span class='ident'>total</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>() <span class='op'>+=</span> <span class='ident'>subsum</span>;
    });

    <span class='kw'>let</span> <span class='ident'>answer</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>total</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
    <span class='ident'>answer</span>
}
</pre>

<p>A sketch of a very simple recursive parallel merge-sort, using
<code>both</code> to handle the recursion. (A working implementation may
really need some temporary buffers to mangle the data, but the key
point is <code>both</code> naturally running things in parallel.)</p>
<pre id='rust-example-rendered' class='rust '>
<span class='doccomment'>/// Merges the two sorted runs `left` and `right`.</span>
<span class='doccomment'>/// That is, after `merge(left, right)`,</span>
<span class='doccomment'>///</span>
<span class='doccomment'>///    left[0] &lt;= left[1] &lt;= ... &lt;= left[last] &lt;= right[0] &lt;= ...</span>
<span class='kw'>fn</span> <span class='ident'>merge</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Ord</span><span class='op'>&gt;</span>(<span class='ident'>left</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>T</span>], <span class='ident'>right</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>T</span>]) {
    <span class='comment'>// magic (but non-parallel, so boring)</span>
}

<span class='kw'>fn</span> <span class='ident'>parallel_merge_sort</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Ord</span> <span class='op'>+</span> <span class='ident'>Send</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>T</span>]) {
   <span class='comment'>// base case</span>
   <span class='kw'>if</span> <span class='ident'>x</span>.<span class='ident'>len</span>() <span class='op'>&lt;=</span> <span class='number'>1</span> { <span class='kw'>return</span> }

   <span class='comment'>// get two disjoint halves of the `x`,</span>
   <span class='kw'>let</span> <span class='ident'>half</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>len</span>() <span class='op'>/</span> <span class='number'>2</span>;
   <span class='kw'>let</span> (<span class='ident'>left</span>, <span class='ident'>right</span>) <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>split_at_mut</span>(<span class='ident'>half</span>);
   <span class='comment'>// and sort them recursively, in parallel</span>
   <span class='ident'>simple_parallel</span>::<span class='ident'>both</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='op'>*</span><span class='ident'>left</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='op'>*</span><span class='ident'>right</span>, <span class='op'>|</span><span class='ident'>v</span><span class='op'>|</span> <span class='ident'>parallel_merge_sort</span>(<span class='ident'>v</span>));

   <span class='comment'>// now combine the two sorted halves</span>
   <span class='ident'>merge</span>(<span class='ident'>left</span>, <span class='ident'>right</span>)
}
</pre>

<p>The <a href="https://github.com/huonw/simple_parallel/tree/master/examples"><code>examples</code>
folder</a>
contains more intricate example(s), such as a parallel fast
Fourier transform implementation (it really works, and the
parallelism does buy something... when tuned).</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Reexports</a></h2>
<table><tr><td><code>pub use one_to_one::{<a class='fn' href='../simple_parallel/one_to_one/fn.map.html' title='simple_parallel::one_to_one::map'>map</a>, <a class='fn' href='../simple_parallel/one_to_one/fn.unordered_map.html' title='simple_parallel::one_to_one::unordered_map'>unordered_map</a>};</code></td></tr><tr><td><code>pub use pool::<a class='struct' href='../simple_parallel/pool/struct.Pool.html' title='simple_parallel::pool::Pool'>Pool</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='mod' href='one_to_one/index.html'
                               title='simple_parallel::one_to_one'>one_to_one</a></td>
                        <td class='docblock short'></td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='mod' href='pool/index.html'
                               title='simple_parallel::pool'>pool</a></td>
                        <td class='docblock short'></td>
                    </tr>
                </table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='fn' href='fn.both.html'
                               title='simple_parallel::both'>both</a></td>
                        <td class='docblock short'><p>Execute <code>f</code> on both <code>x</code> and <code>y</code>, in parallel, returning the
result.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='fn' href='fn.for_.html'
                               title='simple_parallel::for_'>for_</a></td>
                        <td class='docblock short'><p>Execute <code>f</code> on each element of <code>iter</code>, in their own <code>scoped</code>
thread.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "simple_parallel";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>